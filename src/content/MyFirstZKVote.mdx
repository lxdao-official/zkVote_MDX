{/*
  MDX 中的 export 语句必须放在文件最顶部！
  这样变量才能在整个文件中使用
*/}
export const author = "React 学习者";
export const currentYear = 2025;

## My First ZKVote：从链上投票到零知识证明

在这个教程里，你会经历两件事：

1. 先体验一次**完全公开的链上投票**，理解传统区块链投票的优点与局限；
2. 再完成一次基于零知识证明（Zero-Knowledge Proof, ZKP）的匿名投票，亲手走完从「生成证明 → 提交交易 → 链上验证」的完整流程。

本文会用相对严谨但尽量不晦涩的方式，解释 ZK 在投票场景中的原理和工程落地方式，而不仅仅停留在“黑箱魔法”的层面。

## 一、为什么要在区块链上投票？

在传统电子投票系统中，常见的痛点包括：

- 需要信任中心化服务器正确记录和统计选票；
- 难以向公众证明「统计过程没有被篡改」；
- 审计过程高度依赖专业机构，普通选民很难独立验证。

区块链提供了一个自然的解决思路：

- **公开透明**：所有投票交易记录在链上，任何人可以查询与复算；
- **不可篡改**：区块一旦确认，历史记录在经济假设下难以回滚；
- **自动执行**：智能合约按照预先写死的逻辑完成计票与结果发布。

因此，基于区块链的投票系统可以做到所谓的 **端到端可验证性（End-to-End Verifiability）**：

从选票生成、传输、计票到结果发布，每一步都可以被任何第三方独立验证。

然而，「透明」带来可验证性的同时，也引入了一个明显问题：**隐私几乎不存在**。

## 二、传统链上投票的隐私困境

在最简单的链上投票设计中，一个地址对应一张选票：

- 投票就是向投票合约发送一笔交易，调用类似 `vote(proposalId, choice)` 的函数；
- 这笔交易会公开记录：
    - 发起交易的钱包地址 `from`；
    - 调用的合约地址 `to`；
    - 调用的数据（可以反推你投给了哪一个选项）。

以这种方式投票，任何人只要能访问区块浏览器，就可以轻易得到：

- 某个地址参与过多少次投票；
- 每次投票在什么议题上、投给了哪一方；
- 如果这个地址在其他场景已经与现实身份绑定（交易所、社交账号、线下活动），就可以进一步将**真实身份与投票偏好绑定**。

在一些不敏感的社区治理场景，这种公开记录可能是可接受甚至有价值的；

但在涉及政治立场、公司内部表决、薪酬评审等议题时，选民往往希望：

- 自己的选票**不会被公开关联**到某个具体地址或身份；
- 但整个投票过程依然是**可验证的**，不会因为匿名而牺牲正确性。

这就形成了一个经典矛盾：

> 我们既想让选票“可验证”，又希望投票“可匿名”。
> 

零知识证明（Zero-Knowledge Proof）正是解决这一矛盾的核心密码学工具。

## 三、零知识证明基础：证明什么、向谁证明？

### 3.1 Prover / Verifier 模型

零知识证明通常用两个角色来描述：

- **证明者（Prover）**：掌握某个秘密信息，希望向他人证明自己「确实知道」这个秘密；
- **验证者（Verifier）**：希望确认某个断言是真的，但不想（或不允许）知道该秘密本身。

我们把「要被证明的陈述」称为 **语句（statement）**，把证明者掌握的秘密称为 **见证（witness）**。

在投票场景中，一个典型的语句会是：

> “我确实是这场投票中被授权的选民之一，并且我投出的票是一个合法选项。”
> 

而见证则包括：

- 你的私有身份秘密（如某个随机生成的 `identitySecret`）；
- 证明你是选民集合成员所需的 Merkle 路径；
- 你选择的具体投票选项等私密数据。

### 3.2 零知识证明必须满足的三个性质

形式上，一个零知识证明系统需要同时满足三个核心性质：

1. **完备性（Completeness）**
    
    如果语句是真的，并且证明者与验证者都按照协议诚实地执行，那么验证者最终一定会被说服。
    
2. **可靠性 / 可靠性（Soundness）**
    
    如果语句是假的，那么任何试图伪造证明的「作弊」证明者，都几乎不可能骗过诚实的验证者。
    
3. **零知识性（Zero-Knowledge）**
    
    验证者在整个证明过程中，除了“语句是真的”这一事实之外**不会获得任何额外信息**。
    
    换句话说，验证者无法从证明内容中，还原出证明者所掌握的秘密。
    

在投票系统中：

- 完备性保证「合法选民的合法投票不会被无故拒绝」；
- 可靠性保证「非选民或者试图一人多投的人无法通过验证」；
- 零知识性保证「验证者无法从证明中推断出你是谁、投了什么票」。

### 3.3 交互式 vs 非交互式、zk-SNARK 与 zk-STARK

最早的零知识证明是**交互式**的：证明者和验证者要来回多轮问答，才能完成一次证明。

在区块链场景下，这种方式不现实：我们希望证明能以**单个对象**的形式提交到链上，由合约一次性做出判断，因此需要使用 **非交互式零知识证明（NIZK）**。

目前在区块链上常见的两类 NIZK 系统有：

- **zk-SNARK（Zero-Knowledge Succinct Non-Interactive Argument of Knowledge）**
    - *Succinct*：证明大小很小，验证开销与原始计算规模无关或几乎无关；
    - *Non-Interactive*：证明是单向的，不需要多轮交互；
    - 已被广泛用于隐私交易、zk-Rollup 等场景。
- **zk-STARK（Zero-Knowledge Scalable Transparent Argument of Knowledge）**
    - 不依赖可信初始化（trusted setup）；
    - 更适合大规模、复杂计算的场景，但证明大小通常更大。

在 My First ZKVote 中，我们使用的是一类典型的 zk-SNARK 流程，帮助你理解「如何把一个投票规则写成电路，并在浏览器中生成证明」。

实际工程中你可以选择不同 proving system（例如 Groth16、PLONK、Halo2 等），本教程不绑定具体实现，但会保持兼容大多数 zk-SNARK 方案的抽象流程。

## 四、zk-SNARK 系统的一般工作流程

虽然不同库的实现细节不同，但大多数 zk-SNARK 都可以抽象为以下几个步骤：

### 4.1 编写约束系统 / 电路

首先，需要把我们想要证明的逻辑，转换成一种适合电路计算的形式，比如：

- R1CS（Rank-1 Constraint System）约束；
- 或者算术电路（Arithmetic Circuit）形式。

在 ZKVote 场景中，我们想证明的逻辑包括（简化版）：

1. 证明者确实是选民集合中的一员；
2. 这次投票的选项属于允许的取值集合；
3. 为当前投票生成的 nullifier（防重复投票标识）是由身份秘密和投票 ID 计算出来的。

这些条件都会被转化为一系列约束，构成一个「需要被证明的程序」。

### 4.2 Setup：生成证明密钥和验证密钥

在 zk-SNARK 中，通常需要先执行一次 **Setup**：

- 输入：约束系统 / 电路描述；
- 输出：
    - **Proving Key（PK）**：用于之后生成证明；
    - **Verification Key（VK）**：用于之后验证证明。

在很多实现中，这一步需要一个可信设置（Trusted Setup）阶段，由一组参与者共同执行，多余的秘密参数需要在仪式结束后安全销毁，以避免被滥用。

在本教程的上下文里，我们假设：

- Setup 已经通过安全的方式离线完成；
- 合约中已经内置或存储了对应的 `Verification Key`。

### 4.3 证明者本地生成证明

当你准备进行一次 ZK 投票时，浏览器会在本地执行以下操作：

1. 从你的输入中收集**公开输入（public inputs）**：
    - 如投票所属的 `electionId`；
    - 当前选民集合的 Merkle 根 `root` 等。
2. 从本地或钱包中收集**私有输入（witness）**：
    - 你的身份秘密 `identitySecret`；
    - 对应的 Merkle 路径；
    - 你选择的投票选项 `vote`。
3. 调用 zk 证明库，使用 `Proving Key` 计算出一份证明 `proof`。

生成出的证明通常是一个非常短的结构化二进制数据，可以被序列化为 JSON 再发送给智能合约。

### 4.4 智能合约端验证证明

前端会构造一笔交易，调用投票合约的类似函数：

```solidity
function vote(
    Proof proof,
    PublicInputs publicInputs
) external {
    // 1. 调用 Verifier 验证 proof
    // 2. 检查 nullifier 是否已被使用
    // 3. 更新计票结果
}
```

合约内部会执行以下步骤：

1. 调用内置的 Verifier 合约（或预编译）验证 `proof` 与 `publicInputs` 是否匹配且合法；
2. 检查 `nullifier` 是否已经被使用（防止一人多投）；
3. 如果验证通过且 `nullifier` 未使用：
    - 记录该 `nullifier`；
    - 更新投票结果（计票）。

所有这些操作都会生成交易记录，保留在链上，任何人都能复查。

## 五、ZKVote 系统设计：从身份到选票

基于上面的 zk-SNARK 流程，我们可以构造一个通用的 ZK 投票系统模型。这里参考包括 Semaphore 在内的多种匿名信号协议的设计思想。

### 5.1 身份注册与选民集合

在投票开始前，我们需要确定谁有权投票。一个典型流程是：

1. 每个选民在本地生成一个随机秘密 `identitySecret`；
2. 计算对应的 **身份承诺（identity commitment）**：
    
    ```
    identityCommitment = Hash(identitySecret)
    ```
    
3. 所有 `identityCommitment` 被组织成一棵 **Merkle 树**，其根节点 `root` 存储在投票合约中；
4. 选民在本地保存自己的 `identitySecret` 和对应的 Merkle 路径。

在这个模型中：

- 链上只知道「有哪些承诺构成了选民集合」；
- 不知道每个承诺背后是哪一个具体的钱包地址或现实身份。

### 5.2 Nullifier：防止重复投票

为了防止同一个选民多次投票，我们为每次投票定义一个 **nullifier**：

```
nullifier = Hash(identitySecret, electionId)
```

在电路中，我们会强制约束：

- `nullifier` 是由某个合法 `identitySecret` 与当前投票 ID `electionId` 计算得到的；
- 但证明中不会泄露 `identitySecret` 本身，也不会暴露你在 Merkle 树中的位置。

合约只需要确保：

- 对同一个 `electionId`，同一个 `nullifier` 只能使用一次；
- 无论谁提交交易，只要带着一个还没被使用过且证明合法的 `nullifier`，就能完成投票。

### 5.3 投票内容与合法性约束

对于投票选项本身，我们在电路中通常会加入以下约束：

- `vote` 必须是允许的选项之一（例如只能是 {0,1}、或 1~N 之间的整数）；
- 对于多选题，可以约束票数和在某个范围内；
- 如果为了进一步保护隐私，也可以在链上只记录密文或承诺，而不直接记录明文票项。

具体如何处理投票内容与计票过程，会与系统的隐私目标与复杂度要求有关。

部分系统会采用「加密选票 + 同态计票」等技术组合，在保持选票密文形式的前提下完成可验证计票。

在 My First ZKVote 中，我们采用简化模型，重点让你理解以下问题：

- 如何用零知识证明「我有投票资格」；
- 如何防止一人多投；
- 如何在不暴露身份的前提下，把「我参与过这次投票」这一事实公开记录在链上。

## 六、My First ZKVote：完整体验流程说明

本教程将整个体验拆分为两个阶段，以突出普通链上投票与 ZK 投票的差异。

### 6.1 阶段一：体验一次“非 ZK”的链上投票

在第一阶段，你会：

1. 创建或导入一个以太坊钱包（推荐使用浏览器插件钱包）；
2. 切换到 Sepolia 测试网，并领取少量测试 ETH 作为 gas；
3. 使用自己的钱包地址直接调用投票合约的 `vote()` 函数。

完成后，你可以在区块浏览器中看到：

- 你的地址；
- 你的投票选项；
- 交易所在区块、时间戳等信息。

这一阶段的目的是直观地感受：

- 区块链在计票与结果公开方面的透明与可靠；
- 以及这种设计对隐私的影响——你的投票历史将长期与该地址绑定。
<ChainVote />
### 6.2 阶段二：基于 ZK 的匿名投票

在第二阶段，我们切换到基于零知识证明的投票流程。总体步骤如下：

1. **生成身份秘密与承诺**
    - 前端在本地生成 `identitySecret`；
    - 计算 `identityCommitment` 并发送给后台/注册合约；
    - 等待该承诺被加入选民 Merkle 树。
2. **获取最新的选民集合信息**
    - 前端从合约读取当前的 Merkle 根 `root`；
    - 根据你的 `identityCommitment` 计算并存储对应的 Merkle 路径。
3. **在本地构造 ZK 证明**
    - 你在界面中选择「同意 / 反对」等选项；
    - 浏览器端把以下数据输入到证明电路：
        - 私有输入：`identitySecret`、Merkle 路径、`vote`；
        - 公开输入：`root`、`electionId`；
    - 调用 zk 库，使用 `Proving Key` 生成证明 `proof`，同时计算 `nullifier`。
4. **提交投票交易**
    - 前端将 `proof`、`publicInputs`（包含 `root`、`nullifier`、投票选项等必要字段）打包，调用投票合约；
    - 你的钱包会弹出签名与发送交易的确认页面，但交易数据中不包含你的身份秘密。
5. **链上验证与计票**
    - 合约调用 Verifier 合约验证 `proof` 是否有效；
    - 检查 `nullifier` 是否已被使用；
    - 如果验证通过且 `nullifier` 未出现过，则记录这张票并标记 `nullifier` 为已使用。
6. **查看结果与审计**
    - 任何人都可以在链上查看：
        - 每一次投票调用时提供的 `publicInputs`；
        - 以及合约验证通过的事实；
    - 但没有人可以从这些数据中还原出：
        - 具体是哪一个 `identitySecret` 参与了某次投票；
        - 某个真实世界身份在这场投票中选择了什么。

## 七、安全性与局限性

尽管 ZKVote 在隐私方面相对于普通链上投票有巨大改进，但依然需要关注若干安全假设与工程注意点。

1. **可信设置（Trusted Setup）**
    - 许多 zk-SNARK 方案依赖可信设置。如果 Setup 仪式中的秘密参数未被销毁，从理论上讲，攻击者可能伪造看似合法的证明。
2. **浏览器端环境安全**
    - 尽管证明在本地生成，但如果用户的设备被恶意软件控制，身份秘密有被窃取的风险；
    - 教程中应该反复强调：保护好你的浏览器环境与钱包，避免安装来路不明的插件或扩展。
3. **抗胁迫性（Coercion-Resistance）**
    - ZKVote 可以隐藏你“投了什么”，但在现实场景中依然存在「截图界面、当面操作」等强制或收买问题；
    - 抗胁迫通常需要更复杂的协议设计（如可否认投票、混合假票等），超出本教程范围。
4. **性能与可扩展性**
    - 生成证明需要一定计算资源，尤其在手机等设备上；
    - 随着选民数量增长，Merkle 树深度增加，证明生成时间也会变化；
    - 实际部署时往往会结合 zk-Rollup 等扩展方案，将大量证明聚合后再上链。

## 八、你将收获什么？

完成 My First ZKVote 之后，你应当能够清晰地回答：

1. 传统链上投票解决了什么问题，又带来了哪些隐私风险；
2. 零知识证明在投票系统中分别承担哪些责任：
    - 身份隐私；
    - 有资格性验证；
    - 防止一人多投；
3. 一个基于 zk-SNARK 的 ZKVote 系统，从「身份注册 → 生成证明 → 合约验证 → 公共审计」的完整流程；
4. 在工程实践中，部署 ZK 投票系统需要注意的关键假设与安全边界。

在此基础上，你可以继续深入：

- 阅读更多关于 zk-SNARK / zk-STARK 的密码学细节；
- 学习社区项目（如 Semaphore 等）是如何在真实 DAO 中落地匿名投票的；
- 将这里的简化 Demo 扩展为支持多选、加密计票或跨链治理的完整应用。

欢迎你在完成本教程后，结合自己的场景，可以对 ZKVote 做更深度的改造与实验。